package lib_simplersa

import (
	"crypto/rand"
	"math/big"
	"testing"
)

func TestKeyGenerationSimple(t *testing.T) {
	size := 2048
	if testing.Short() {
		size = 128
	}
	priv, err := GenerateKey(rand.Reader, size)
	if err != nil {
		t.Errorf("failed to generate key")
	}
	if bits := priv.N.BitLen(); bits != size {
		t.Errorf("key too short (%d vs %d)", bits, size)
	}
	t.Log(priv.N.BitLen())
	//testKeyBasics(t, priv)
}

func TestKeyGeneration(t *testing.T) {
	size := 1024
	if testing.Short() {
		size = 128
	}
	priv, err := GenerateKey(rand.Reader, size)
	if err != nil {
		t.Errorf("failed to generate key")
	}
	if bits := priv.N.BitLen(); bits != size {
		t.Errorf("key too short (%d vs %d)", bits, size)
	}
	testKeyBasics(t, priv)
}

func Test3PrimeKeyGeneration(t *testing.T) {
	size := 768
	if testing.Short() {
		size = 256
	}

	priv, err := GenerateMultiPrimeKey(rand.Reader, 3, size)
	if err != nil {
		t.Errorf("failed to generate key")
	}
	testKeyBasics(t, priv)
}

func Test4PrimeKeyGeneration(t *testing.T) {
	size := 768
	if testing.Short() {
		size = 256
	}

	priv, err := GenerateMultiPrimeKey(rand.Reader, 4, size)
	if err != nil {
		t.Errorf("failed to generate key")
	}
	testKeyBasics(t, priv)
}

func TestNPrimeKeyGeneration(t *testing.T) {
	primeSize := 64
	maxN := 24
	if testing.Short() {
		primeSize = 16
		maxN = 16
	}
	// Test that generation of N-prime keys works for N > 4.
	for n := 5; n < maxN; n++ {
		priv, err := GenerateMultiPrimeKey(rand.Reader, n, 64+n*primeSize)
		if err == nil {
			testKeyBasics(t, priv)
		} else {
			t.Errorf("failed to generate %d-prime key", n)
		}
	}
}

func TestImpossibleKeyGeneration(t *testing.T) {
	// This test ensures that trying to generate toy RSA keys doesn't enter
	// an infinite loop.
	for i := 0; i < 32; i++ {
		GenerateKey(rand.Reader, i)
		GenerateMultiPrimeKey(rand.Reader, 3, i)
		GenerateMultiPrimeKey(rand.Reader, 4, i)
		GenerateMultiPrimeKey(rand.Reader, 5, i)
	}
}

func TestGnuTLSKey(t *testing.T) {
	// This is a key generated by `certtool --generate-privkey --bits 128`.
	// It's such that de ≢ 1 mod φ(n), but is congruent mod the order of
	// the group.
	priv := &PrivateKey{
		PublicKey: PublicKey{
			N: fromBase10("290684273230919398108010081414538931343"),
			E: 65537,
		},
		D: fromBase10("31877380284581499213530787347443987241"),
		Primes: []*big.Int{
			fromBase10("16775196964030542637"),
			fromBase10("17328218193455850539"),
		},
	}
	testKeyBasics(t, priv)
}

func testKeyBasics(t *testing.T, priv *PrivateKey) {
	if err := priv.Validate(); err != nil {
		t.Errorf("Validate() failed: %s", err)
	}
	if priv.D.Cmp(priv.N) > 0 {
		t.Errorf("private exponent too large")
	}

	pub := &priv.PublicKey
	m := big.NewInt(42)
	c := encrypt(pub, m)

	m2, err := decrypt(nil, priv, c)
	if err != nil {
		t.Errorf("error while decrypting: %s", err)
		return
	}
	if m.Cmp(m2) != 0 {
		t.Errorf("got:%v, want:%v (%+v)", m2, m, priv)
	}

	m3, err := decrypt(rand.Reader, priv, c)
	if err != nil {
		t.Errorf("error while decrypting (blind): %s", err)
	}
	if m.Cmp(m3) != 0 {
		t.Errorf("(blind) got:%v, want:%v (%#v)", m3, m, priv)
	}
}

func fromBase10(base10 string) *big.Int {
	i, ok := new(big.Int).SetString(base10, 10)
	if !ok {
		panic("bad number: " + base10)
	}
	return i
}

var test2048Key *PrivateKey

func init() {
	test2048Key = &PrivateKey{
		PublicKey: PublicKey{
			N: fromBase10("14314132931241006650998084889274020608918049032671858325988396851334124245188214251956198731333464217832226406088020736932173064754214329009979944037640912127943488972644697423190955557435910767690712778463524983667852819010259499695177313115447116110358524558307947613422897787329221478860907963827160223559690523660574329011927531289655711860504630573766609239332569210831325633840174683944553667352219670930408593321661375473885147973879086994006440025257225431977751512374815915392249179976902953721486040787792801849818254465486633791826766873076617116727073077821584676715609985777563958286637185868165868520557"),
			E: 3,
		},
		D: fromBase10("9542755287494004433998723259516013739278699355114572217325597900889416163458809501304132487555642811888150937392013824621448709836142886006653296025093941418628992648429798282127303704957273845127141852309016655778568546006839666463451542076964744073572349705538631742281931858219480985907271975884773482372966847639853897890615456605598071088189838676728836833012254065983259638538107719766738032720239892094196108713378822882383694456030043492571063441943847195939549773271694647657549658603365629458610273821292232646334717612674519997533901052790334279661754176490593041941863932308687197618671528035670452762731"),
		Primes: []*big.Int{
			fromBase10("130903255182996722426771613606077755295583329135067340152947172868415809027537376306193179624298874215608270802054347609836776473930072411958753044562214537013874103802006369634761074377213995983876788718033850153719421695468704276694983032644416930879093914927146648402139231293035971427838068945045019075433"),
			fromBase10("109348945610485453577574767652527472924289229538286649661240938988020367005475727988253438647560958573506159449538793540472829815903949343191091817779240101054552748665267574271163617694640513549693841337820602726596756351006149518830932261246698766355347898158548465400674856021497190430791824869615170301029"),
		},
	}
	test2048Key.Precompute()
}

func Benchmark2048GenerateKey(b *testing.B) {
	size := 2048
	if testing.Short() {
		size = 128
	}
	for i := 0; i < b.N; i++ {
		GenerateKey(rand.Reader, size)
	}
}

func BenchmarkRSA2048Decrypt(b *testing.B) {
	b.StopTimer()

	c := fromBase10("8472002792838218989464636159316973636630013835787202418124758118372358261975764365740026024610403138425986214991379012696600761514742817632790916315594342398720903716529235119816755589383377471752116975374952783629225022962092351886861518911824745188989071172097120352727368980275252089141512321893536744324822590480751098257559766328893767334861211872318961900897793874075248286439689249972315699410830094164386544311554704755110361048571142336148077772023880664786019636334369759624917224888206329520528064315309519262325023881707530002540634660750469137117568199824615333883758410040459705787022909848740188613313")

	b.StartTimer()

	for i := 0; i < b.N; i++ {
		decrypt(nil, test2048Key, c)
	}
}

//func BenchmarkRSA2048Sign(b *testing.B) {
//	b.StopTimer()
//	hashed := sha256.Sum256([]byte("testing"))
//	b.StartTimer()
//
//	for i := 0; i < b.N; i++ {
//		SignPKCS1v15(rand.Reader, test2048Key, crypto.SHA256, hashed[:])
//	}
//}

func Benchmark3PrimeRSA2048Decrypt(b *testing.B) {
	b.StopTimer()
	priv := &PrivateKey{
		PublicKey: PublicKey{
			N: fromBase10("16346378922382193400538269749936049106320265317511766357599732575277382844051791096569333808598921852351577762718529818072849191122419410612033592401403764925096136759934497687765453905884149505175426053037420486697072448609022753683683718057795566811401938833367954642951433473337066311978821180526439641496973296037000052546108507805269279414789035461158073156772151892452251106173507240488993608650881929629163465099476849643165682709047462010581308719577053905787496296934240246311806555924593059995202856826239801816771116902778517096212527979497399966526283516447337775509777558018145573127308919204297111496233"),
			E: 3,
		},
		D: fromBase10("10897585948254795600358846499957366070880176878341177571733155050184921896034527397712889205732614568234385175145686545381899460748279607074689061600935843283397424506622998458510302603922766336783617368686090042765718290914099334449154829375179958369993407724946186243249568928237086215759259909861748642124071874879861299389874230489928271621259294894142840428407196932444474088857746123104978617098858619445675532587787023228852383149557470077802718705420275739737958953794088728369933811184572620857678792001136676902250566845618813972833750098806496641114644760255910789397593428910198080271317419213080834885003"),
		Primes: []*big.Int{
			fromBase10("1025363189502892836833747188838978207017355117492483312747347695538428729137306368764177201532277413433182799108299960196606011786562992097313508180436744488171474690412562218914213688661311117337381958560443"),
			fromBase10("3467903426626310123395340254094941045497208049900750380025518552334536945536837294961497712862519984786362199788654739924501424784631315081391467293694361474867825728031147665777546570788493758372218019373"),
			fromBase10("4597024781409332673052708605078359346966325141767460991205742124888960305710298765592730135879076084498363772408626791576005136245060321874472727132746643162385746062759369754202494417496879741537284589047"),
		},
	}
	priv.Precompute()

	c := fromBase10("8472002792838218989464636159316973636630013835787202418124758118372358261975764365740026024610403138425986214991379012696600761514742817632790916315594342398720903716529235119816755589383377471752116975374952783629225022962092351886861518911824745188989071172097120352727368980275252089141512321893536744324822590480751098257559766328893767334861211872318961900897793874075248286439689249972315699410830094164386544311554704755110361048571142336148077772023880664786019636334369759624917224888206329520528064315309519262325023881707530002540634660750469137117568199824615333883758410040459705787022909848740188613313")

	b.StartTimer()

	for i := 0; i < b.N; i++ {
		decrypt(nil, priv, c)
	}
}
